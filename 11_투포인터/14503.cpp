// 14503: 로봇 청소기 (골드5/구현, 시뮬레이션)
#include <iostream>     // 입출력 스트림 포함

using namespace std;    // std 이름공간 선언

const int SIZE = 50;    // 보드의 사이즈 선언
const int CLEAN = 2;    // 입력받은 (0: 빈 칸, 1: 벽) 외에 로직에서 필요한 값 (2: 청소 완료) 선언
int n, m, cnt = 0;      // 세로 크기, 가로 크기, 청소한 칸 개수

int board[SIZE][SIZE]; // 칸의 상태를 저장할 2차원 전역배열 선언
int dx[4] = {0, 1, 0, -1}, dy[4] = {-1, 0, 1, 0}; // 북 동 남 서를 각각 0,1,2,3번 index로 두어 해당 방향으로 로봇이 움직일 시의 변위를 저장


void dfs(int row, int col, int dir) {   // 입력받은 로봇청소기를 작동시키면서 정보를 업데이트


    // 1. 현재 위치 청소
    if(board[row][col] != CLEAN) {  // 현재 장소가 청소가 안되어있다면
        cnt++;                      // 청소 횟수 증가
    }
    board[row][col] = CLEAN;        // 현재 장소 청소



    // [현재 칸의 주변 4칸 중 청소되지 않은 빈 칸이 있는가]
    // 3. 현재 칸의 주변 4칸 중 청소되지 않은 빈 칸이 있는 경우

    for(int i = 0; i < 4; i++) {                                        // 3-1. 반시계 방향으로 90º 회전 - 한바퀴 돌며 빈칸 발견할 때까지 반복, 찾으면 종료
        int new_dir = (dir-i+3) % 4;                                    // 반시계방향 90도 회전한 방향에 해당하는 인덱스 계산
        int new_row = row + dy[new_dir], new_col = col + dx[new_dir];   // 계산한 방향 쪽으로 한 칸 이동했을 때의 좌표 계산

        if(board[new_row][new_col] == 0) {      // 3-2. 아직 청소되지 않은 빈 칸 발견
            dfs(new_row, new_col, new_dir);     // 로봇을 한 칸 전진시켜 dfs 호출
            return;                             // 함수 종료
        }
    }

    // 2. 현재 칸의 주변 4칸 중 청소되지 않은 빈 칸이 없는 경우
    int back_dir = (dir+2) % 4;                                         // 현재 가리키는 방향의 반대 방향에 해당하는 인덱스 계산
    int back_row = row + dy[back_dir], back_col = col + dx[back_dir];   // 계산한 방향 쪽으로 한 칸 이동했을 때의 좌표 계산

    // [바라보는 방향을 유지한 채로 한 칸 후진할 수 있는가]
    // 2-2. 뒤쪽 칸이 벽이라 후진할 수 없는 경우
    if(board[back_row][back_col] == 1) {    // 뒤쪽 칸이 벽이라면
        return;                             // 로봇청소기가 이동할 수 없으므로 로봇 작동 종료
    }
    // 2-1. 바라보는 방향을 유지한 채로 한 칸 후진
    dfs(back_row, back_col, dir); // 방향 유지한 상태로 후진시켜 dfs 호출 (2-3)
    return;                       // 함수 종료
}

/*
 * [로봇 청소기 작동]
 * 1. 현재 칸이 아직 청소되지 않은 경우, 현재 칸을 청소한다.
 * 2. 현재 칸의 주변 4칸 중 청소되지 않은 빈 칸이 없는 경우,
 *  2-1. 바라보는 방향을 유지한 채로 한 칸 후진할 수 있다면 한 칸 후진하고 1번으로 돌아간다.
 *  2-2. 바라보는 방향의 뒤쪽 칸이 벽이라 후진할 수 없다면 작동을 멈춘다.
 * 3. 현재 칸의 주변 4칸 중 청소되지 않은 빈 칸이 있는 경우,
 *  3-1. 반시계 방향으로 90º 회전한다.
 *  3-2. 바라보는 방향을 기준으로 앞쪽 칸이 청소되지 않은 빈 칸인 경우 한 칸 전진한다.
 *  3-3. 1번으로 돌아간다.
*/

int main() {
    int r, c, d;                    // 로봇 청소기 정보

    // 입력
    cin >> n >> m;                  // 방의 세로, 가로(3 <= (n, m) <= 50) 입력
    cin >> r >> c >> d;             // 처음에 로봇 청소기가 있는 칸의 좌표(r,c)와 바라보는 방향 d(0,1,2,3) 입력

    for(int i = 0; i < n; i++) {    // 세로 n회
        for(int j = 0; j < m; j++) {// 가로 m회 동안 모든 칸 순회
            cin >> board[i][j];     // 방의 각 장소에 대한 정보 입력
        }
    }

    
    dfs(r, c, d);                   // 로봇청소기가 청소를 완료할때까지 작동시키며 방의 상태를 갱신

    cout << cnt;                    // 방 상태와 함께 갱신된 청소 횟수 값을 출력

    return 0;                       // 프로그램 종료
}